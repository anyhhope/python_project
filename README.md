# Система по детекции объектов из видео-потока

Система микросервисов для **чтения rtsp потока**, **разбиения его на кадры** с помощью OpenCV и **детекции объектов** с кадров с помощью YOLO-модели. Микросервисы общаются посредством message broker'а - **kafka**. Кроме того, реализован **паттерн хреографии** и предусмотрено отслеживание состояний, а также компенсирующие действия сервисов при возникновении ошибки. Система **асинхронная**, а rtsp-потоки обрабатываются **параллельно в разных процессах**. Данные о состоянии хранятся в Postgres, а кадры с bounding box'ами детекции - в s3-хранилище

**Стек и библиотеки:**
* FastApi
* asyncio
* multiprocessing
* Kafka - aiokafka
* Postgres - asyncpg
* S3 - minio
* Модель Yolo - ultralitics

## Api-сервис

### POST 
* */init* - Запуск стейт-машины, отправка ссылки на rtsp-поток
* */shutdown* - Остановка стейт-машины по id

### GET 
* */detection_result* - Получение результатов детекции в виде списка ссылок на изображения в s3-хранилище
* */state* - Получение текущего состояния стейт-машины

При инициализации стейт-машины сервис в рамках одной транзакции пишет в две таблицы: одна хранит информацию о запросах и их состояниях, а дргуая - outbox таблица, из которой producer отправляет сообщения в следующий сервис

## Runner-сервис

Занимается предобработкой кадров с rtsp-потока с помощью OpenCV и отправкой кадров в ML-сервис с помощью кафки. Для каждого нового запроса пользователя создается отдельный процесс(multiprocessing) в котором обрабатывается поток

## ML-сервис

Получает кадры из runner'а и распознает объекты на кадрах с помощью Yolo, распознанные кадры сохраняет в s3-хранилище, а информацию о детекции и ссылки на кадры в Postgres

Для каждого нового запроса создается отдельный процесс, а новые кадры поступают в уже существующий процесс через очередь 

## State-manager-сервис

Занимается отслеживанием состояний, прослушивая топик state кафки и заменой состояния в Postgres. При получения сообщения о состоянии init_shutdown, дожидается когда все сервисы отправят подтверждения, что они прервали процесс для текущего id, только после этого сохраняет состояние inactive, если сервисы закончили без ошибки, inactive_error - если с ошибкой

Состояния:

```python
STARTUP = "init_startup" # sends client -> STARTUP_PROCESS
SHUTDOWN = "init_shutdown" # sends client -> SHUTDOWN_PROCESS
SHUTDOWN_PROCESS = "in_shutdown_processing"
STARTUP_PROCESS = "in_startup_processing"
RUNNER_PROCESS = "runner_started" #runner started process
ML_PROCESS = "ml_started" #ml started process
INACTIVE_OK = "inactive" #stop process without error / answer to shutdown
INACTIVE_ERROR = "inactive_error" #stop process with error / answer to shutdown
```    